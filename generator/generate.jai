jai_types :: Type.[
    s8,
    s16,
    s32,
    s64,
    u8,
    u16,
    u32,
    u64,
    float32,
    float64,
];

#run {
    target := get_build_options();
    target.output_type = .NO_OUTPUT;
    set_build_options(target);

    print("\n:: Generating types...\n");

    types := get_type_list();
    longest := 0;
    
    for 0..types.count - 1 {
        str := to_string(types.list[it].type_id);
        if str.count > longest then longest = str.count;
    }

    builder: String_Builder;
    print_to_builder(*builder, MODULE_START);

    for 0..types.count - 1 {
        c_type  := types.list[it];
        type_id := to_string(c_type.type_id);

        append(*builder, type_id);
        for 0..(longest - type_id.count - 1) append(*builder, #char " ");
        append(*builder, " :: #type ");

        for type: jai_types {
            info := cast(*Type_Info)type;
            if info.runtime_size != c_type.size continue;

            if info.type == {
                case .INTEGER;
                    if c_type.flags & .Float continue;

                    unsigned := !(cast(*Type_Info_Integer)info).signed;
                    if (c_type.flags & .Unsigned) && !unsigned continue;

                    print_to_builder(*builder, "%;\n", type);
                    break;

                case .FLOAT;
                    if !(c_type.flags & .Float) continue;
                    print_to_builder(*builder, "%;\n", type);
                    break;
            }
        }
    }

    os_string := tprint("%", OS);
    to_lower(os_string);
    filename := tprint("generated_%.jai", os_string);

    if !write_entire_file(filename, builder) {
        print(":: Unable to create file: %\n", filename);
        return;
    }

    print(":: Finished generating file: %\n", filename);
}

MODULE_START :: #string END
// This file was automatically generated by 'generator/generate.jai'
// Do not edit this by hand.

END;

Type_Flags :: enum u32 {
    None;
    Unsigned;
    Float;
}

Type_Description :: struct {
    type_id : *u8;
    size    : s64;
    flags   : Type_Flags;
}

Type_List :: struct {
    count: s64;
    list: *Type_Description;
}

sizes :: #foreign_library "sizes"; // Run build.bat/build.sh to create this.
get_type_list :: () -> Type_List #foreign sizes;

#import "Basic";
#import "File";
#import "String";
#import "Compiler";
